// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var CONST, Phaser, SECOND, SpriteGUI, addBlendModeController, addControllerAndSaveNumericValue, createMap, dat, freeze, freezeDeep, isArray, saveNumericValue, spriteProps,
    hasProp = {}.hasOwnProperty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dat = dat || (typeof window !== "undefined" && window !== null ? window.dat : void 0) || (typeof require === "function" ? require("dat.gui") : void 0);

  Phaser = Phaser || (typeof window !== "undefined" && window !== null ? window.Phaser : void 0) || (typeof require === "function" ? require("phaser") : void 0);

  if (!dat) {
    throw new Error("Can't find `dat`");
  }

  if (!Phaser) {
    throw new Error("Can't find `Phaser`");
  }

  isArray = Array.isArray;

  freeze = Object.freeze;

  SECOND = 1000;

  freezeDeep = function(obj) {
    var val;
    for (val in obj) {
      if (!hasProp.call(obj, val)) continue;
      if (typeof val === "object") {
        freezeDeep(val);
      }
    }
    return freeze(obj);
  };

  CONST = freezeDeep({
    alpha: {
      range: [0, 1, 0.1]
    },
    anchor: {
      range: [0, 1, 0.1]
    },
    angle: {
      range: [-180, 180, 5],
      step: 5
    },
    bounce: {
      range: [0, 1, 0.1]
    },
    drag: {
      range: [0, 1000, 10]
    },
    dragDistanceThreshold: {
      range: [0, 10, 1]
    },
    dragOffset: {
      range: [-100, 100, 5]
    },
    dragTimeThreshold: {
      range: [0, 100, 10]
    },
    friction: {
      range: [0, 1, 0.1]
    },
    gravity: {
      range: [-1000, 1000, 10]
    },
    health: {
      range: [1, 100, 1]
    },
    lifespan: {
      range: [0, 10 * SECOND, 100]
    },
    mass: {
      range: [0.1, 10, 0.1]
    },
    maxAngular: {
      range: [0, 1000, 10]
    },
    maxVelocity: {
      range: [0, 10000, 10]
    },
    offset: {
      range: [-100, 100, 1]
    },
    rotation: {
      range: [-Math.PI, Math.PI, Math.PI / 30],
      step: Math.PI / 30
    },
    pixelPerfectAlpha: {
      range: [0, 255, 5]
    },
    priorityID: {
      range: [0, 10, 1]
    },
    snap: {
      range: [0, 100, 5]
    },
    snapOffset: {
      range: [-100, 100, 5]
    },
    scale: {
      range: [-10, 10, 0.1],
      min: -10,
      max: 10,
      step: 0.1
    }
  });

  addControllerAndSaveNumericValue = function(guiContainer, obj, propName, args) {
    var controller;
    controller = guiContainer.add(obj, propName, args);
    controller.onChange(saveNumericValue);
    return controller;
  };

  addBlendModeController = function(guiContainer, obj, propName) {
    return addControllerAndSaveNumericValue(guiContainer, obj, propName, Phaser.blendModes);
  };

  createMap = function(arr) {
    var i, key, len, map;
    map = {};
    for (i = 0, len = arr.length; i < len; i++) {
      key = arr[i];
      map[key] = true;
    }
    return map;
  };

  saveNumericValue = function(newValue) {
    this.object[this.property] = Number(newValue);
  };

  spriteProps = function(sprite) {
    var animations, body, bounds, height, input, ref, scaleRange, width, world, worldRangeHeight, worldRangeWidth, worldRangeX, worldRangeY, worldRect;
    world = sprite.game.world;
    bounds = world.bounds;
    animations = sprite.animations, body = sprite.body, input = sprite.input;
    ref = sprite.texture.frame, width = ref.width, height = ref.height;
    scaleRange = [sprite.scaleMin || CONST.scale.min, sprite.scaleMax || CONST.scale.max, CONST.scale.step];
    worldRangeX = [bounds.left, bounds.right, 10];
    worldRangeY = [bounds.top, bounds.bottom, 10];
    worldRangeWidth = [0, bounds.width, 10];
    worldRangeHeight = [0, bounds.height, 10];
    worldRect = {
      x: worldRangeX,
      y: worldRangeY,
      width: worldRangeWidth,
      height: worldRangeHeight
    };
    return freezeDeep({
      alive: true,
      alpha: CONST.alpha.range,
      autoCull: true,
      animations: animations.currentAnim ? {
        paused: true,
        stop: true,
        updateIfVisible: true
      } : false,
      anchor: {
        x: CONST.anchor.range,
        y: CONST.anchor.range
      },
      blendMode: addBlendModeController,
      bringToTop: true,
      body: body && body.type === Phaser.Physics.ARCADE ? {
        allowGravity: true,
        allowRotation: true,
        angularAcceleration: [-body.maxAngular, body.maxAngular, CONST.angle.step],
        angularDrag: [0, 2 * body.maxAngular, CONST.angle.step],
        angularVelocity: [-body.maxAngular, body.maxAngular, CONST.angle.step],
        bounce: {
          x: CONST.bounce.range,
          y: CONST.bounce.range
        },
        collideWorldBounds: true,
        drag: {
          x: CONST.drag.range,
          y: CONST.drag.range
        },
        enable: true,
        friction: {
          x: CONST.friction.range,
          y: CONST.friction.range
        },
        gravity: {
          x: CONST.gravity.range,
          y: CONST.gravity.range
        },
        immovable: true,
        mass: CONST.mass.range,
        maxAngular: CONST.maxAngular.range,
        maxVelocity: {
          x: CONST.maxVelocity.range,
          y: CONST.maxVelocity.range
        },
        moves: true,
        offset: {
          x: CONST.offset.range,
          y: CONST.offset.range
        },
        rotation: CONST.angle.range,
        skipQuadTree: true,
        velocity: {
          x: [-body.maxVelocity.x, body.maxVelocity.x],
          y: [-body.maxVelocity.y, body.maxVelocity.y]
        }
      } : false,
      cacheAsBitmap: true,
      cameraOffset: {
        x: worldRangeX,
        y: worldRangeY
      },
      checkWorldBounds: true,
      debug: true,
      exists: true,
      fixedToCamera: true,
      frame: typeof sprite.frame === "number" ? [0, animations.frameTotal - 1, 1] : [animations.frameData.getFrameIndexes()],
      frameName: true,
      health: [CONST.health.min, sprite.maxHealth, CONST.health.step],
      input: input ? {
        allowHorizontalDrag: true,
        allowVerticalDrag: true,
        boundsRect: input.boundsRect ? worldRect : false,
        dragDistanceThreshold: CONST.dragDistanceThreshold.range,
        draggable: true,
        dragOffset: {
          x: CONST.dragOffset.range,
          y: CONST.dragOffset.range
        },
        dragStopBlocksInputUp: true,
        dragTimeThreshold: CONST.dragTimeThreshold.range,
        bringToTop: true,
        enabled: true,
        pixelPerfectAlpha: CONST.pixelPerfectAlpha.range,
        pixelPerfectClick: true,
        pixelPerfectOver: true,
        priorityID: CONST.priorityID.range,
        reset: true,
        snapOffsetX: CONST.snapOffset.range,
        snapOffsetY: CONST.snapOffset.range,
        snapOnDrag: true,
        snapOnRelease: true,
        snapX: CONST.snap.range,
        snapY: CONST.snap.range,
        stop: true,
        useHandCursor: true
      } : false,
      key: true,
      kill: true,
      lifespan: CONST.lifespan.range,
      maxHealth: CONST.health.range,
      moveDown: true,
      moveUp: true,
      name: true,
      outOfBoundsKill: true,
      outOfCameraBoundsKill: true,
      pivot: {
        x: [-bounds.width, bounds.width, 10],
        y: [-bounds.height, bounds.height, 10]
      },
      renderable: true,
      reset: true,
      revive: true,
      rotation: CONST.rotation.range,
      scale: {
        x: scaleRange,
        y: scaleRange
      },
      sendToBack: true,
      smoothed: true,
      tilePosition: sprite.tilePosition ? {
        x: [0, width, 1],
        y: [0, height, 1]
      } : false,
      tileScale: sprite.tileScale ? {
        x: CONST.scale.range,
        y: CONST.scale.range
      } : false,
      tint: true,
      visible: true,
      x: worldRangeX,
      y: worldRangeY,
      z: true
    });
  };

  freeze(SpriteGUI = (function(superClass) {
    extend(SpriteGUI, superClass);

    SpriteGUI.prototype.exclude = null;

    SpriteGUI.prototype.include = null;

    function SpriteGUI(sprite1, params, options) {
      this.sprite = sprite1;
      if (params == null) {
        params = {};
      }
      if (options == null) {
        options = {};
      }
      SpriteGUI.__super__.constructor.call(this, params);
      if (options) {
        if (options.include) {
          this.include = createMap(options.include);
          this.filter = this.filterInclude;
        } else if (options.exclude) {
          this.exclude = createMap(options.exclude);
          this.filter = this.filterExclude;
        }
      }
      this.addAll();
    }

    SpriteGUI.prototype.add = function(obj, prop) {
      var val;
      val = obj[prop];
      if (val == null) {
        console.warn("Skipping property '" + prop + "': " + val);
      } else {
        return SpriteGUI.__super__.add.apply(this, arguments);
      }
    };

    SpriteGUI.prototype.addAll = function() {
      this.addProps(this, this.sprite, spriteProps(this.sprite));
    };

    SpriteGUI.prototype.addProps = function(guiContainer, obj, props) {
      var args, name;
      for (name in props) {
        args = props[name];
        this.addProp(guiContainer, obj, name, args);
      }
      return guiContainer;
    };

    SpriteGUI.prototype.addProp = function(guiContainer, obj, name, args) {
      var addArgs, field, result, val;
      if (args === false || !this.filter(name)) {
        return;
      }
      val = obj[name];
      if (val == null) {
        console.warn("Skipping property '" + name + "': " + val);
        return;
      }
      if (typeof args === "function") {
        result = args.call(null, guiContainer, obj, name);
        args = isArray(result) ? result : false;
      }
      switch (false) {
        case args !== false:
          return;
        case args !== true:
          field = guiContainer.add(obj, name);
          if (typeof val !== "function") {
            field.listen();
          }
          break;
        case !isArray(args):
          addArgs = [obj, name].concat(args);
          guiContainer.add.apply(guiContainer, addArgs).listen();
          break;
        case typeof args !== "object":
          this.addProps(guiContainer.addFolder(name), obj[name], args);
          break;
        default:
          console.warn("Nothing to do: " + args);
      }
      return guiContainer;
    };

    SpriteGUI.prototype.filter = function() {
      return true;
    };

    SpriteGUI.prototype.filterExclude = function(name) {
      return !this.exclude[name];
    };

    SpriteGUI.prototype.filterInclude = function(name) {
      return this.include[name];
    };

    return SpriteGUI;

  })(dat.GUI));

  Phaser.SpriteGUI = SpriteGUI;

  if (typeof window !== "undefined" && window !== null) {
    window.SpriteGUI = SpriteGUI;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SpriteGUI;
  }

}).call(this);
